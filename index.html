<head>
    <link rel="stylesheet" href="./style.css">

    <script>var exports = {};</script>
    <script src="https://unpkg.com/@google/generative-ai@0.16.0/dist/index.js"></script>
</head>


<button id="removeAiToken" class="hidden bottomLeft join-button" onclick="removeToken()">REMOVE TOKEN</button>

<canvas id="drawingCanvas" class="hidden"></canvas>

<div id="noAiTokenSet" class="hidden">
    <center>
        <h3>Looks like you haven't set a Google Gemini token! This is required for this calculator to work!</h3>
        <label for="tokenInput">Enter your <strong>Google Gemini</strong> token.</label>
        <br>
        <input name="tokenInput" id="tokenInput" class="input" placeholder="GOOGLE GEMINI TOKEN">
        <button onclick="submitToken()" class="join-button">SUBMIT TOKEN</button>
        <br>
        <br>
        <br>
    </center>
</div>




<!--  Setup global functions like cookies and sleep  -->
<script>
    const sleep = ms => new Promise(res => setTimeout(res, ms));

    function setCookie(cname, cvalue, exdays) {
        const d = new Date();
        d.setTime(d.getTime() + (exdays*24*60*60*1000));
        let expires = "expires="+ d.toUTCString();
        document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
    }
    function getCookie(cname) {
        let name = cname + "=";
        let decodedCookie = decodeURIComponent(document.cookie);
        let ca = decodedCookie.split(';');
        for(let i = 0; i <ca.length; i++) {
            let c = ca[i];
            while (c.charAt(0) == ' ') {
                c = c.substring(1);
            }
            if (c.indexOf(name) == 0) {
                return c.substring(name.length, c.length);
            }
        }
        return "";
    }
</script>

<!--  Token setup and cookies  -->
<script>
    let token = getCookie("geminiToken")
    if(token == ""){
        noToken()
    }
    else{
        token = atob(token)
        weHaveToken()
    }

    function weHaveToken(){
        document.getElementById("noAiTokenSet").classList.add("hidden")
        document.getElementById("removeAiToken").classList.remove("hidden")
        document.getElementById("drawingCanvas").classList.remove("hidden")
    }
    function noToken(){
        document.getElementById("noAiTokenSet").classList.remove("hidden")
        document.getElementById("removeAiToken").classList.add("hidden")
        document.getElementById("drawingCanvas").classList.add("hidden")
    }

    function submitToken(){
        token = document.getElementById("tokenInput").value
        if(token != ""){
            setCookie("geminiToken", btoa(token), 9999)
            weHaveToken()
            setGeminiAiToken(token)
            document.getElementById("tokenInput").value = ""
        }
    }

    function removeToken(){
        setCookie("geminiToken", "", 1)
        noToken()
        
        token = ""
        setGeminiAiToken("")
    }
</script>

<!--  Canvas Stuff  -->
<script>
    const c = document.getElementById("drawingCanvas")
    c.width = window.innerWidth
    c.height = window.innerHeight
    const ctx = c.getContext("2d", { willReadFrequently: true })

    reset()

    var undoStack = []
    var isMouseDown = false
    var brushSize = 1
    var previousCords = {x: -1, y: -1}
    
    var lastResult = null

    // equal sign detection stuff
    var mousePositionInDraw = []
    var previousMousePositionInDraw = []
    var slopeToleranceForStraitLine = .5
    var acceptableDistanceForEqualSign = 30
    var wasLastDrawingStrait = false
    var resultCords = {x: -1, y: -1}

    function reset(){
        undoStack = []
        let oldFill = ctx.fillStyle
        ctx.fillStyle = "#FFFFFF"
        ctx.fillRect(0,0, c.width, c.height)
        ctx.fillStyle = oldFill
    }

    function paintAtCords(x, y){
        // circle brush
        for(let x1 = x-brushSize; x1 <= x+brushSize; x1++){
            for(let y1 = y-brushSize; y1 <= y+brushSize; y1++){
                let distFromCenter = calculateDistance(x, y, x1, y1)
                if(distFromCenter <= brushSize){
                    ctx.fillRect(x1, y1, 1, 1)
                }
            }
        }
    }

    function calculateDistance(x1, y1, x2, y2){
        return Math.sqrt( Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2) )
    }

    function loadState(stateImage){
        ctx.putImageData(stateImage, 0, 0);
    }

    function undo(){
        if(undoStack.length == 0){ return } // nothing to undo!
        let previousState = undoStack.pop()
        loadState(previousState)
    }
    
    function didDrawStrait(positions){
        let isStrait = true
        let didWork = false
        for(let i=5; i<positions.length; i+=5){
            didWork = true
            let a = positions[i-5]
            let b = positions[i]

            let rise = b.y - a.y
            let run = b.x - a.x
            let slope = rise / run
            if(slope > slopeToleranceForStraitLine || slope < -slopeToleranceForStraitLine){
                isStrait = false
                break
            }
        }
        if(didWork == false){ return false }
        return isStrait
    }

    c.onmousedown = function(e){
        if(e.button != 0){ return } // we only want the left mouse button

        isMouseDown = true;
        previousCords = {x: e.pageX, y: e.pageY}
        previousMousePositionInDraw = mousePositionInDraw
        mousePositionInDraw = []
        
        let canvasData = ctx.getImageData(0, 0, c.width, c.height)
        undoStack.push(canvasData)
    }
    c.onmouseup = async function(e){
        if(e.button != 0){ return } // we only want the left mouse button

        isMouseDown = false;

        isStrait = didDrawStrait(mousePositionInDraw)
        if(isStrait && wasLastDrawingStrait){
            let xBoundsOfDrawing = [mousePositionInDraw[0].x, mousePositionInDraw[0].x]
            let yAverage = 0
            for(let i=0;i<mousePositionInDraw.length;i++){
                let value = mousePositionInDraw[i].x
                xBoundsOfDrawing[0] = Math.min(xBoundsOfDrawing[0], value)
                xBoundsOfDrawing[1] = Math.max(xBoundsOfDrawing[1], value)
                yAverage += mousePositionInDraw[i].y
            }
            yAverage /= mousePositionInDraw.length

            let xBoundsOfPreviousDrawing = [previousMousePositionInDraw[0].x, previousMousePositionInDraw[0].x]
            let yAveragePrevious = 0
            for(let i=0;i<previousMousePositionInDraw.length;i++){
                let value = previousMousePositionInDraw[i].x
                xBoundsOfPreviousDrawing[0] = Math.min(xBoundsOfPreviousDrawing[0], value)
                xBoundsOfPreviousDrawing[1] = Math.max(xBoundsOfPreviousDrawing[1], value)
                yAveragePrevious += previousMousePositionInDraw[i].y
            }
            yAveragePrevious /= previousMousePositionInDraw.length

            let minDiff = Math.sqrt(Math.pow(xBoundsOfDrawing[0] - xBoundsOfPreviousDrawing[0], 2))
            let maxDiff = Math.sqrt(Math.pow(xBoundsOfDrawing[1] - xBoundsOfPreviousDrawing[1], 2))
            let diffY = Math.sqrt(Math.pow(yAverage - yAveragePrevious, 2))
            console.log(xBoundsOfDrawing, xBoundsOfPreviousDrawing)

            let range = acceptableDistanceForEqualSign * brushSize
            if(minDiff <= range && maxDiff <= range && diffY <= range){
                console.log("equals sign detected")
                resultCords = {
                    x: Math.max(xBoundsOfDrawing[0], xBoundsOfDrawing[1], xBoundsOfPreviousDrawing[0], xBoundsOfPreviousDrawing[1]),
                    y: Math.min(yAverage, yAveragePrevious)
                }


                // draw a red equals sign
                let canvasData = ctx.getImageData(0, 0, c.width, c.height)
                let oldColor = ctx.fillStyle
                ctx.fillStyle = "#FF0000"

                let equalSignMousePositions = mousePositionInDraw.concat(previousMousePositionInDraw)
                for(let i=0; i<equalSignMousePositions.length;i++){
                    let position = equalSignMousePositions[i]
                    paintAtCords(position.x, position.y)
                }
                let coloredEqualsSign = c.toDataURL("image/jpeg")


                // send the image data to Google Gemini
                console.log(coloredEqualsSign)
                let binaryString = coloredEqualsSign.replace(/^data:image\/jpeg;base64,/, '');

                let image = {
                    inlineData: {
                        data: binaryString,
                        mimeType: "image/jpeg"
                    }
                }
                geminiRunPrompt(image, (result)=>{
                    result = JSON.parse(result)
                    let lastResult = result

                    if(result.isSolvable == false){
                        result.variables = {}
                        result.finalResult = "This equation is not possible"
                    }
                    if(result.doesHaveASolution == false){
                        result.variables = {}
                        result.finalResult = "This equation has no solution"
                    }

                    console.log(result)

                    ctx.font = "48px serif"

                    let variables = Object.keys(lastResult.variables)
                    if(variables.length > 0){
                        let x = resultCords.x
                        let y = resultCords.y + (diffY * 5)
                        for(let i=0; i<variables.length; i++){
                            let variableName = variables[i]
                            let variableValue = lastResult.variables[variableName]

                            ctx.fillText(variableName + " = " + variableValue, x, y)
                            y += 48
                        }
                    }
                    else{
                        ctx.fillText(lastResult.finalResult, resultCords.x + 10, resultCords.y)
                    }
                }, (e)=>{
                    console.error(e)
                })
                
                // load the state before changing equals sign color
                ctx.fillStyle = oldColor
                loadState(canvasData)
            }
        }

        wasLastDrawingStrait = isStrait // update for next draw

        paintAtCords(e.pageX, e.pageY)
    }
    
    c.onmousemove = function(e){
        if(!isMouseDown) return;
    
        let x = e.pageX;
        let y = e.pageY;

        let depth = calculateDistance(x, y, previousCords.x, previousCords.y)
        let dx = (x - previousCords.x) / depth
        let dy = (y - previousCords.y) / depth
        for(let i = 0; i < depth; i++){
            nx = previousCords.x + i * dx
            ny = previousCords.y + i * dy
            paintAtCords(nx, ny)
        }

        previousCords = {x: x, y: y}
        mousePositionInDraw.push(previousCords)
        
        return false;
    }
</script>

<!--  Google Gemini API  -->
<script>
    var systemInstructions = `You are a calculator. You WILL follow PEMDAS. You will be given an image with an equation on it. You need to solve the equation that pairs with the red equals sign. You WILL ONLY respond with JSON. Take a deep breath, keep calm, You will do fine. You HAVE to break the problem into steps and list them. Here is an outline you MUST follow for responses
{
"steps": [], // list of strings on how you solve said step as well as the name of the step
"finalResult": 0, // NUMBER, you MUST CALCULATE this value (UNLESS SOLVING FOR VARIABLE)
"isSolvable": false, // Is this equation possible? ex. 1 = 2
"doesHaveASolution": false, // does it have a solution? If there is a variable who's value isn't solvable set this to false
"variables": {x: 0, y: 0, z: 0}, // Put all the variables and their values. Leave this empty, {}, if no variables are being solved for. You will leave variables empty if you are not solving for a variable, ex. x = 2; 5x = ? set variables to {} and final result is 10 (2 * 5)
}`

    const safetySettings = [
        {
            category: exports.HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
            threshold: exports.HarmBlockThreshold.BLOCK_NONE,
        },
        {
            category: exports.HarmCategory.HARM_CATEGORY_HARASSMENT,
            threshold: exports.HarmBlockThreshold.BLOCK_NONE,
        },
        {
            category: exports.HarmCategory.HARM_CATEGORY_HATE_SPEECH,
            threshold: exports.HarmBlockThreshold.BLOCK_NONE,
        },
        {
            category: exports.HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
            threshold: exports.HarmBlockThreshold.BLOCK_NONE,
        },
    ];
    
    var modelName = "gemini-1.5-flash"

    var genAI = new exports.GoogleGenerativeAI(token);
    var model = genAI.getGenerativeModel({
        model: modelName,
        systemInstruction: systemInstructions,
        safetySettings
    })

    const generationConfig = {
        temperature: 1,
        topP: 0.95,
        topK: 64,
        maxOutputTokens: 8192,
        responseMimeType: "text/plain",
    };

    function setGeminiAiToken(TOKEN){
        genAI = new exports.GoogleGenerativeAI(TOKEN);
        model = genAI.getGenerativeModel({
            model: modelName,
            systemInstruction: systemInstructions,
            safetySettings
        })
    }

    function geminiRunPrompt(image, resultFunction, failureFunction){
        model.generateContent(["Solve the equation with the red equals sign", image])
        .then((result)=>{
            text = result.response.text()
            resultFunction(text)
        })
        .catch(failureFunction)
    }

    function printResult(result){
        console.log(result)
    }
</script>