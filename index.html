<head>
    <link rel="stylesheet" href="./style.css">

    <script>var exports = {};</script>
    <script src="https://unpkg.com/@google/generative-ai@0.16.0/dist/index.js"></script>
</head>


<button id="removeAiToken" class="hidden bottomLeft join-button" onclick="removeToken()">REMOVE TOKEN</button>

<canvas id="drawingCanvas" class="hidden"></canvas>

<div id="noAiTokenSet" class="hidden">
    <center>
        <h3>Looks like you haven't set a Google Gemini token! This is required for this calculator to work!</h3>
        <label for="tokenInput">Enter your <strong>Google Gemini</strong> token.</label>
        <br>
        <input name="tokenInput" id="tokenInput" class="input" placeholder="GOOGLE GEMINI TOKEN">
        <button onclick="submitToken()" class="join-button">SUBMIT TOKEN</button>
        <br>
        <br>
        <br>
    </center>
</div>




<!--  Setup global functions like cookies and sleep  -->
<script>
    const sleep = ms => new Promise(res => setTimeout(res, ms));

    function setCookie(cname, cvalue, exdays) {
        const d = new Date();
        d.setTime(d.getTime() + (exdays*24*60*60*1000));
        let expires = "expires="+ d.toUTCString();
        document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
    }
    function getCookie(cname) {
        let name = cname + "=";
        let decodedCookie = decodeURIComponent(document.cookie);
        let ca = decodedCookie.split(';');
        for(let i = 0; i <ca.length; i++) {
            let c = ca[i];
            while (c.charAt(0) == ' ') {
                c = c.substring(1);
            }
            if (c.indexOf(name) == 0) {
                return c.substring(name.length, c.length);
            }
        }
        return "";
    }
</script>

<!--  Token setup and cookies  -->
<script>
    let token = getCookie("geminiToken")
    if(token == ""){
        noToken()
    }
    else{
        token = atob(token)
        weHaveToken()
    }

    function weHaveToken(){
        document.getElementById("noAiTokenSet").classList.add("hidden")
        document.getElementById("removeAiToken").classList.remove("hidden")
        document.getElementById("drawingCanvas").classList.remove("hidden")
    }
    function noToken(){
        document.getElementById("noAiTokenSet").classList.remove("hidden")
        document.getElementById("removeAiToken").classList.add("hidden")
        document.getElementById("drawingCanvas").classList.add("hidden")
    }

    function submitToken(){
        token = document.getElementById("tokenInput").value
        if(token != ""){
            setCookie("geminiToken", btoa(token), 9999)
            weHaveToken()
            setGeminiAiToken(token)
            document.getElementById("tokenInput").value = ""
        }
    }

    function removeToken(){
        setCookie("geminiToken", "", 1)
        noToken()
        
        token = ""
        setGeminiAiToken("")
    }
</script>

<!--  Canvas Stuff  -->
<script>
    const c = document.getElementById("drawingCanvas")
    c.width = window.innerWidth
    c.height = window.innerHeight
    const ctx = c.getContext("2d", { willReadFrequently: true })

    var undoStack = []
    var isMouseDown = false
    var selectedColor = "#000000"
    var brushSize = 1
    var previousCords = {x: -1, y: -1}
    
    // equal sign detection stuff
    var mousePositionInDraw = []
    var slopeToleranceForStraitLine = .5
    var acceptableDistanceForEqualSign = 30
    var wasLastDrawingStrait = false

    function reset(){
        undoStack = []
        let oldFill = ctx.fillStyle
        ctx.fillStyle = "#FFFFFF"
        ctx.fillRect(0,0, c.width, c.height)
        ctx.fillStyle = oldFill
    }

    function paintAtCords(x, y){
        // circle brush
        for(let x1 = x-brushSize; x1 <= x+brushSize; x1++){
            for(let y1 = y-brushSize; y1 <= y+brushSize; y1++){
                let distFromCenter = calculateDistance(x, y, x1, y1)
                if(distFromCenter <= brushSize){
                    ctx.fillRect(x1, y1, 1, 1)
                }
            }
        }
    }

    function calculateDistance(x1, y1, x2, y2){
        return Math.sqrt( Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2) )
    }

    function loadState(stateImage){
        ctx.putImageData(stateImage, 0, 0);
    }

    function undo(){
        if(undoStack.length == 0){ return } // nothing to undo!
        let previousState = undoStack.pop()
        loadState(previousState)
    }
    
    function didDrawStrait(positions){
        let isStrait = true
        let didWork = false
        for(let i=5; i<positions.length; i+=5){
            didWork = true
            let a = positions[i-5]
            let b = positions[i]

            let rise = b.y - a.y
            let run = b.x - a.x
            let slope = rise / run
            if(slope > slopeToleranceForStraitLine || slope < -slopeToleranceForStraitLine){
                isStrait = false
                break
            }
        }
        if(didWork == false){ return false }
        return isStrait
    }

    c.onmousedown = function(e){
        isMouseDown = true;
        previousCords = {x: e.pageX, y: e.pageY}
        mousePositionInDraw = []
        
        let canvasData = ctx.getImageData(0, 0, c.width, c.height)
        undoStack.push(canvasData)
    }
    c.onmouseup = function(e){
        isMouseDown = false;

        isStrait = didDrawStrait(mousePositionInDraw)
        if(isStrait && wasLastDrawingStrait){
            
        }

        wasLastDrawingStrait = isStrait // update for next draw

        paintAtCords(e.pageX, e.pageY)
    }
    
    c.onmousemove = function(e){
        if(!isMouseDown) return;
    
        let x = e.pageX;
        let y = e.pageY;

        let depth = calculateDistance(x, y, previousCords.x, previousCords.y)
        let dx = (x - previousCords.x) / depth
        let dy = (y - previousCords.y) / depth
        for(let i = 0; i < depth; i++){
            nx = previousCords.x + i * dx
            ny = previousCords.y + i * dy
            paintAtCords(nx, ny)
        }

        previousCords = {x: x, y: y}
        mousePositionInDraw.push(previousCords)
        
        return false;
    }
</script>

<!--  Google Gemini API  -->
<script>
    var genAI = new exports.GoogleGenerativeAI(token);
    var model = null

    const safetySettings = [
        {
            category: exports.HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
            threshold: exports.HarmBlockThreshold.BLOCK_NONE,
        },
        {
            category: exports.HarmCategory.HARM_CATEGORY_HARASSMENT,
            threshold: exports.HarmBlockThreshold.BLOCK_NONE,
        },
        {
            category: exports.HarmCategory.HARM_CATEGORY_HATE_SPEECH,
            threshold: exports.HarmBlockThreshold.BLOCK_NONE,
        },
        {
            category: exports.HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
            threshold: exports.HarmBlockThreshold.BLOCK_NONE,
        },
    ];

    const generationConfig = {
        temperature: 1,
        topP: 0.95,
        topK: 64,
        maxOutputTokens: 8192,
        responseMimeType: "text/plain",
    };

    var systemInstructions = ``

    function setGeminiAiToken(TOKEN){
        genAI = new exports.GoogleGenerativeAI(TOKEN);
        model = genAI.getGenerativeModel({
            model: "gemini-1.5-flash",
            systemInstruction: systemInstructions,
            safetySettings
        })
    }

    function geminiRunPrompt(prompt, resultFunction, failureFunction){
        const chatSession = model.startChat({
            generationConfig,
            history: [],
        });
        chatSession.sendMessage(prompt)
            .then((result)=>{
                text = result.response.text()
                resultFunction(text)
            })
            .catch(failureFunction)
    }

    function printResult(result){
        console.log(result)
    }
</script>